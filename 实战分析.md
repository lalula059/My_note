# 分析

1.第一步，看f12文档里面所需资料是否直接存储在html文档里面。
3.分析文件那一份是本体而不是构建工具构建的第三方库
2.看cookie以及token等值是否存在
4.如果有cookie这些，1.全局搜索或者2.堆zha，3.构建xhr请求断点，查找原函数

2.异步编程，session和信号量尽量设置为全局，设置为函数有可能不起作用，因为你需要所有的携程共享着一个信号量，要么就传递到aiohttpget下，这样才会在共享下
信号量是对clientsession的实例进行复用的限制，不能在创建clientsession外面。。且，必须要你创建的任务列表（也就是一群任务中）中共享一个信号量。
信号量定义是控制携程并发数量的，所以定义在协程下。定义在请求携程下，就是控制请求携程的并发数量，所以全局创建好一些.携程是程序员创建的，你需要控制他，你如果直接定义在里面
你创建了那么多任务，相当于一个任务一个新的信号量，所以需要全局或者更上一级传递给他。且他控制当前携程的，跟await有点像。，注意sem信号量默认的循环，一定要在循环里面设置，或者指明事件循环。。。await挂起当前携程，等到所有的携程执行完右边的，在进行下一步
3.__path__是包的属性，需要导入包，才能正确输出包的路径。
4.对于携程信号量和clientsession的全局创建要进行一些实验，如果clientsession全局创建，但是信号量是在类里面init创建。。注意，因为信号量需要你自己设置loop事件循环，你默认init
就在你开启的事件循环之前设置信号量了，就是俩个事件循环，会报错。要么就global要么就在开启的事件循环里面设置类属性。
5.你可以用try except else玩出花来，也可以当判断来用，而不是每次都设置flag
6.协程报错tasks  被销毁但是还是在等待状态，说明有东西没有await执行，。await等到右边及其他进入事件循环执行完，才进行下一步。
7,**无限debugger可以通过****调试栏目1.本地换js，本地换js如果有多个debugger点,有可能是递归debugger，测试了一个他将不会输出调用堆或者2.fiddler抓包换js。3.右键debugger位置添加条件断点设置false。。4右键左边栏目一律不再此处暂停5,右边停用所有断点，但是这不好，你自己的设置也会被跳**,
8.如果js用了webpack等打包文件，第三方库不是自己编写就会像Vendor取名或者endor-chunk一样。构建过程中还会为每一个文件生成哈希值。

## tips

1.想要快速找函数开头，就看前面对齐位置
2.commonjs规范
3.js有个对象解构，其实就是把对象对应的值取出来比如p={"x":"213","asd":123} 取值const {x} = p...console.log(x)  输出213。还有数组解构，按照顺序赋值。
4.域名虚拟主机主要针对公网，应为公网域名不同但是ip可能一样，所以需要设置域名请求转移，转发到相应的虚拟主机，其实就是域名请求路由。。局域网可以设置端口映射或者反向代理（主要是端口）。
但是你如果想设置的话，可以在局域网内部设置本地DNS服务，将多个域名映射到本地的IP。也算，但是主要针对是公网定义
5.安装包注意冲突，zlib包nodejs有了，不需要在安装
6,篡改猴的脚本必须在要修改的页面中设置，然后添加保存之后，刷新页面
9,python中print("{:_<100}")用这个可以向右边填充_，还可以向左边换成>也可以中间^

### 网站列表

1 Vidhub
2。kkmzt.com
无限debugger 分析到源头可以找到一个，可以直接return，替换之后发现还有，刷新，会出现调用，不刷新没得，原来是一个自执行函数，return。
对于实战的数组constructor的话就hook  Function.prototype.constructor对了
如果hook cookie找属性名，，对象的属性名就是cookie所以Object.defineProperty(document,'cookie',{
    set:function () {
        debugger        
    }
})
3.跟值处理，赋值js代码在vscode找赋值点，一定在当前环境下找当前值，不是一个函数，而是跟进去有值的，写了hook代码直接换页面，不需要刷新，跟dom节点打断点的时候，看网页结构是否刷新
### 经验

1.不缓存刷新ctrl+f5
2.最后一个调试很有用，按照执行顺序来。。
3.跟值有1.补环境  2.经验找关键字  3.hook   4.dom断点   5.xhr发送文件断点   6全局搜索定位  7看堆栈
4.闭包也很重要。
5.补环境有一个一个补，但是我自己一般是全扣下来，在完成jquery的代码的时候进行全局进入，然后返回全局变量，一个一个补的好处是，他有可能将源代码进行修改加密，所以需要一个一个观察
6，关键词 beforsend  success  onload   ajax  等
7.xpath想要遍历每个节点必须要在当前节点下也就是要加.号，要不然还是从顶层开始
8.可以hook json数据的strintyfy和parse后面那个是将json数据转换为对象操作
9. js实例化直接用括号new括起来可以直接实例化

### 补环境
1.函数的tostring，与实例化对象的toString以及函数是否执行时候的toString，然后就是实例化的this执行，浏览器会检测是否报错new
注意，虽然直接toString不加括号在nodejs里面出现的anonymous但是，在浏览器环境下还是一样的，所以说不加括号它根本检测不了，只修改原型链就行
2.execjs,有时候python得不到值原来是因为arraybuffer得不到值，当然也有可能是输出不了，所以说得不到值，格式不对，所以需要转换成16进制数据。。注意-------如果传输的是二进制
需要js进行base64编码在进行传输，python中在解码就行
3.arraybuffer其实就是缓冲区，更高效，因为不需要编码解码，就是二进制，也就是说，你看到的arraybuffer，其实就是二进制变成数组，每八位为一个字节，长度都一样，所以可以list
4.注意将arraybuffer进行base64编码，不是直接编码二进制，而是将二进制转成成字符串编码假设你有一个数组 [255, 128, 0, 0, 0, 0, 0, 0]，你可以将其转换为一个字符串 "255,128,0,0,0,0,0,0"，然后对这个字符串进行 Base64 编码。
数字列表：[255, 128, 0, 0, 0, 0, 0, 0]
转换为字符串："255,128,0,0,0,0,0,0"
Base64 编码这个字符串："MjU1LDEyOCwwLDAsMCwwLDAsMA=="


## 一些实战总结

1.63题原来是不是uint8array对象并没啥用，只是遍历二进制数组转成ascll再弄，转成unint8知识可以进行后续操作在js中，如果在python中传输二进制数组需要使用list后面跟上content就行，然后得到的二进制数组是逐字符base64不是每整数进行base64
"2已完成第十三课课程任务  需要这个因为有时候定时器需要做任务..
// 首先补环境,发现出值了,结果不一样,找他加密点,看出了什么问题
//然后仔细看了每一步,原来它是检测nnavigotor里面的环境,比如说language,webdriver等属性。这一课的监测点需要好好学习一哈"
3。对于jsvmp原理有了了解，其实就是相当于一个简单的编译器，在自治性函数里面需要寄存器保存变量值，然后转换成中间代码用核心逻辑解密，插桩就是打日志断点，中间代码一般都是三地址代码
4# 注意要匹配换行字符，需要加上re.DOTALL  dot是点的意思 all所有
"5.要注意console是修改了对象的话在复制给另外一个对象，引用数据类型会消失var _console = console
var console = {};
console.log = function(){};"


"6，完成千山鸟飞绝这道题，对于异步和websocket有了新的了解# 这一道题首先是补环境，很快，然后传输数据不行，为啥呢是因为，而且需要对websocket链接有基本的了解比如说有时候运行不了是因为你并没有连接成功
，你要把onopen移动位置，移动到上面才行，这样才能等待连接成功，用的websocket链接，是异步操作，
所以直接输出没有结果，直接函数返回也没有,然后就有微队列了的原理了，你需要用另外一个异步操作等待用到了微队列，比如说settimeout..
但是另外一个问题出来了，execjs好像并不支持异步操作，所以这道题需要用with popen。"
"7//笔记，先要补环境，他帮我重写了xmlhttp方法，所以你添加的时候，可以直接添加，还是利用的闭包。自执行传递yrx_Rfuncrion，传递俩个参数，
//一个就是各种send方法等,，，，因为他分开了俩个js文件，所以你需要对html进行传值，自执行，得到js然后,没得自执行那个ajax发送答案，然后替换后面的js文件，注意复制的时候要注意不要格式化，它有格式化检测，所以执行不了，怎么发现的呢，是因为好像执行了之后没有几万行记录代码"
8 基于栈的虚拟机结构和基于寄存器的虚拟机区别  第一个虚拟机不需要知道操作数的具体地址，只需要调用栈指执行POP操作就可以获取下一个操作数。第二个代码中存在很多减法表达式时，寄存器模型可以计算一次后便将计算结果存储在寄存器中，再次执行相同减法表达式时使用寄存器存储的值，从而减少了表达式重复计算造成的开销，我们学习的jsvmp课程里面的是第一个。。。



1.虚拟机是借助于操作系统对物理系统的模拟，自己实现了俩种，一种是基于栈的，一种是基于寄存器的，栈要慢很多，寄存器的要快，但是前一个更简单，在自己实现简单的jsvmp文件里面	
2//其中注意的就是window下的localStorage是自己的，你要重新构建，navigotor检测环境里面需要仔细，最后就是创建类，直接创建error类，注意new的时候传入的this或者其他神恶魔的东西，然后调用stack可以得到值，你就写get然后完成.第五天完成课程，可以看下一趟课了	第一步就是分析请求流程，然后是执行流程，对ajax进行修改自执行post，然后修改第二份返回的网页注意不要格式化，hook时间修改时间，这样保持值固定。然后找到了那个opreataor。。。要自己分析哈它的流程

3完成了简单的ob混淆也就是21题，其实就是找到虚拟机执行的eval删掉，环境都没怎么补，主要就是异步还是选择用popen。在js中转成json文件传给python好用			
4.十六课就是BOM指纹检测，之前的navigator就是DOM指纹检测。通了，之前的分析总结一哈就是BOM，dom，还有打开控制台tostring检测。然后学习了代理和反射的一些知识			
5用代理拦截了delete	补充，左边第一行代码是你想复制输出func，但是它修改了原对象和方法，修改了原对象导致你赋值的也没了，修改了方法，你复制的也没了这时候需要，你要直接赋值_CONSOLE=CONSOLE.LOG,因为你修改的console，只是把console的引用变了，但是原本的引用并没改变，因为你并没赋值_console = console。扩展就可以hook对象要注意，那相反既然有些内置对象属性修改不了，那我就设置源对象		
6完成第二题使用代理拦截delete，let a = {'x':100};a.__proto__=location;a.href会报错这种情况,使用描述符拦截取location			
完成第十六课程中所有的课程内容，BOM检测，navigotor检测插件，里面的嵌套调用和每次都实例化一个i虚拟的，，接下来是typeof的检测，检测typeof对于后面的应用计数，其实就是取值，然后对于每一个typeof进行相应的输出，并且还可以代理检测得到什么东西。。nodejs做框架并不好用，因为多了不好弄，补环境的思想都是一样的，对应啥补啥，广泛的就是可以删掉或者直接固定，狭义的就是争取做成框架，利用语言规则来写。自行学习沙箱。。getownpropertydescriptor自己做框架一定要hook这个。reflect的是全局执行的			
当你在对象字面量内定义属性并使用 this 关键字时，this 并不指向该对象本身，而是指向当前的执行上下文。在严格模式下，this 在全局范围内是 undefined，而在非严格模式下，this 在全局范围内是 window 对象。因此，在对象字面量内不能直接使用 this 访问该对象的其他属性。所以直接定义x={p:3,fg:this.p}是不行的，需要用函数执行上下文才行，这次对于构造函数，这个函数和this俩个字又有了新的理解，如果想变化实例就let一个并且objectdefineproperty并返回他			
c语言和计算机：对于输入缓冲区和io文件还有流有了更好的理解，c处理的也是流			

这周了解了需要学习jsdom和沙盒还有基于babel的ast编译，先把babel玩熟		


1，为啥直接输出console.log(this)是空，查看网页https://segmentfault.com/q/1010000005128554
2.了解了V8引擎，是将js和webassemble转换成机器码，其内置汇编转换器，机器码是计算机直接识别的代码
3容器主要就是对硬件层面的cpu，内存和io以及软件层面的系统的资源视图等进行隔离.容器技术实现了对硬件资源（如CPU、内存、I/O）的隔离和对软件资源视图（如进程、文件系统、网络、用户和组、IPC、主机名和域名）的隔离
3知道了ORM和ODM的区别，一个着重数据，一个着重数据之间的关系，ODM着重于json数据，文档格式自由，ORM着重sql，数据之间规范，行列表等
4.学习了expreess框架服务器的使用，以及数据库的相关操作，使用的是odm，利用的mongodb，其实主要就是怎么和恶mongodb进行操作。其实就是看你用哪种数据库
ORM: Object-Relational Mapping（对象关系映射）
ODM: Object-Document Mapping（对象文档映射）
"数据库使用的ORM和ODM，其主要依据是数据类型和关联性。如果数据是结构化且关联性强的，通常使用ORM来管理关系型数据库；如果数据是文档类型的，格式各异且关联性较弱，则通常使用ODM来管理文档型数据库。"
"Babel 将 ES6 规范的 JavaScript 或其他规范的 JavaScript 转换成 ES5 规范的代码，然后通过 V8 引擎进行编译并转换成机器码
5.了解了基础babel产生原因和功能，其实它是编译器，并且为了浏览器不支持ES6的，转换为抽象语法树，将其中的特性转变成为ES5能够识别的代码，比如箭头函数这些，然后babel分为三种个库很重要，1解释ast，2遍历ast和替换ast  3.生成新的ast
6.了解了使用ast常量折叠和函数直接执行替换。
6.完成了一道表情包加密
7使用简洁的方法定义或属性初始化器来定义函数是合法的，而直接声明函数是不合法的。
